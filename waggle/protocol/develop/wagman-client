#!/usr/bin/env python3
import argparse
import asyncio
import sys
import binascii
import logging
from protocol import pack_sensorgram, unpack_sensorgram, unpack_sensorgrams


async def read_queue_task(reader, queue):
    while True:
        data = await reader.readline()
        logging.debug('read data - %s', data)

        try:
            messages = unpack_sensorgrams(binascii.a2b_base64(data))
        except (binascii.Error, IndexError):
            continue

        for message in messages:
            logging.debug('read msg - %s', message)
            await queue.put(message)


def create_read_queue(reader):
    queue = asyncio.Queue()
    asyncio.create_task(read_queue_task(reader, queue))
    return queue


async def write_queue_task(writer, queue):
    while True:
        message = await queue.get()
        logging.debug('write msg - %s', message)
        data = binascii.b2a_base64(pack_sensorgram(message))
        logging.debug('write data - %s', data)
        writer.write(data)
        await writer.drain()


def create_write_queue(writer):
    queue = asyncio.Queue()
    asyncio.create_task(write_queue_task(writer, queue))
    return queue


async def get_responses(reader, id, sub_ids):
    results = {}
    matches = [{'id': id, 'sub_id': sub_id} for sub_id in sub_ids]

    while len(results) < len(matches):
        message = await reader.get()

        for i, match in enumerate(matches):
            if match_message(match, message):
                results[i] = message['value']

    return tuple(results[i] for i in range(len(results)))


def match_message(fields, msg):
    for k in fields.keys():
        if k not in msg or msg[k] != fields[k]:
            return False
    return True


REQ_WAGMAN_ID = 0xc000
REQ_WAGMAN_CU = 0xc001
REQ_WAGMAN_HB = 0xc002
REQ_WAGMAN_TH = 0xc003
REQ_WAGMAN_UPTIME = 0xc004
REQ_WAGMAN_BOOTS = 0xc005
REQ_WAGMAN_FC = 0xc006
REQ_WAGMAN_START = 0xc007
REQ_WAGMAN_STOP = 0xc008
REQ_WAGMAN_RESET = 0xc009
REQ_WAGMAN_EERESET = 0xc00a
REQ_WAGMAN_DEVICE_STATE = 0xc00b
REQ_WAGMAN_DEVICE_ENABLE = 0xc00c
REQ_WAGMAN_GET_MEDIA_SELECT = 0xc00d
REQ_WAGMAN_SET_MEDIA_SELECT = 0xc00e

PUB_WAGMAN_ID = 0xff1a
PUB_WAGMAN_CU = 0xff06
PUB_WAGMAN_HB = 0xff09
PUB_WAGMAN_BOOTS = 0xff1a
PUB_WAGMAN_UPTIME = 0xff14
PUB_WAGMAN_FC = 0xff05
PUB_WAGMAN_START = 0xff0b
PUB_WAGMAN_STOP = 0xff0a
PUB_WAGMAN_EERESET = 0xc00a
PUB_WAGMAN_RESET = 0xc009
PUB_WAGMAN_PING = 0xff1e
PUB_WAGMAN_VOLTAGE = 0xff08
PUB_WAGMAN_TH = 0xff10
PUB_WAGMAN_DEVICE_STATE = 0xff1f
PUB_WAGMAN_DEVICE_ENABLE = 0xff20
PUB_WAGMAN_GET_MEDIA_SELECT = 0xff21
PUB_WAGMAN_SET_MEDIA_SELECT = 0xff22


def ints(args):
    return [int(x) for x in args]


def ports_to_sub_ids(args):
    return [x + 1 for x in args]


async def put_request(writer, id, sub_ids):
    return await asyncio.gather(*[writer.put({'id': id, 'sub_id': sub_id, 'value': 0})
                                  for sub_id in sub_ids])


commands = {}


def defcommand(table, *names):
    def decorator(func):
        for name in names:
            table[name] = func
        return func
    return decorator


# TODO Try to unify some of the structure. Right now, it looks close...
# but there's small corner cases to prevent easy refactoring across all
# commands.

@defcommand(commands, 'id')
async def command_id(reader, writer, *args):
    await put_request(writer, REQ_WAGMAN_ID, [1])
    return await get_responses(reader, PUB_WAGMAN_ID, [1])


@defcommand(commands, 'cu')
async def command_cu(reader, writer, *args):
    sub_ids = ports_to_sub_ids(ints(args) or [0, 1, 2, 3, 4, 5])
    await put_request(writer, REQ_WAGMAN_CU, sub_ids)
    return await get_responses(reader, PUB_WAGMAN_CU, sub_ids)


@defcommand(commands, 'hb')
async def command_hb(reader, writer, *args):
    sub_ids = ports_to_sub_ids(ints(args) or [0, 1, 2, 3, 4])
    await put_request(writer, REQ_WAGMAN_HB, sub_ids)
    return await get_responses(reader, PUB_WAGMAN_HB, sub_ids)


@defcommand(commands, 'boots')
async def command_boots(reader, writer, *args):
    await put_request(writer, REQ_WAGMAN_BOOTS, [1])
    return await get_responses(reader, PUB_WAGMAN_BOOTS, [1])


@defcommand(commands, 'up', 'uptime')
async def command_uptime(reader, writer, *args):
    await put_request(writer, REQ_WAGMAN_UPTIME, [1])
    return await get_responses(reader, PUB_WAGMAN_UPTIME, [1])


@defcommand(commands, 'fc')
async def command_fc(reader, writer, *args):
    sub_ids = ports_to_sub_ids(ints(args) or [0, 1, 2, 3, 4])
    await put_request(writer, REQ_WAGMAN_FC, sub_ids)
    return await get_responses(reader, PUB_WAGMAN_FC, sub_ids)


@defcommand(commands, 'th')
async def command_th(reader, writer, *args):
    sub_ids = ports_to_sub_ids(ints(args) or [0, 1, 2, 3, 4])
    await put_request(writer, REQ_WAGMAN_TH, sub_ids)
    return await get_responses(reader, PUB_WAGMAN_TH, sub_ids)


@defcommand(commands, 'start')
async def command_start(reader, writer, *args):
    sub_id = int(args[0]) + 1
    await writer.put({'id': REQ_WAGMAN_START, 'sub_id': sub_id, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_START, [sub_id])


@defcommand(commands, 'stop')
async def command_stop(reader, writer, *args):
    sub_id = int(args[0]) + 1
    after = int(args[1])
    await writer.put({'id': REQ_WAGMAN_STOP, 'sub_id': sub_id, 'value': after})
    return await get_responses(reader, PUB_WAGMAN_STOP, [sub_id])


@defcommand(commands, 'eereset')
async def command_eereset(reader, writer, *args):
    await writer.put({'id': REQ_WAGMAN_EERESET, 'sub_id': 1, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_EERESET, [1])


@defcommand(commands, 'reset')
async def command_reset(reader, writer, *args):
    await writer.put({'id': REQ_WAGMAN_RESET, 'sub_id': 1, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_RESET, [1])


@defcommand(commands, 'enable')
async def command_enable(reader, writer, *args):
    sub_id = int(args[0]) + 1
    await writer.put({'id': REQ_WAGMAN_DEVICE_ENABLE, 'sub_id': sub_id, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_DEVICE_ENABLE, [sub_id])


@defcommand(commands, 'state')
async def command_enable(reader, writer, *args):
    sub_id = int(args[0]) + 1
    await writer.put({'id': REQ_WAGMAN_DEVICE_STATE, 'sub_id': sub_id, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_DEVICE_STATE, [sub_id])


media_table = {
    'sd': 0,
    'emmc': 1,
}


@defcommand(commands, 'bs')
async def command_enable(reader, writer, *args):
    sub_id = int(args[0]) + 1

    if len(args) == 1:
        await writer.put({'id': REQ_WAGMAN_GET_MEDIA_SELECT, 'sub_id': sub_id, 'value': 0})
        value = await get_responses(reader, PUB_WAGMAN_GET_MEDIA_SELECT, [sub_id])
        if value == (0,):
            return 'sd'
        elif value == (1,):
            return 'emmc'
        else:
            return 'invalid'
    else:
        media = media_table[args[1]]
        await writer.put({'id': REQ_WAGMAN_SET_MEDIA_SELECT, 'sub_id': sub_id, 'value': (media,)})
        return await get_responses(reader, PUB_WAGMAN_SET_MEDIA_SELECT, [sub_id])


def stringify(x):
    if isinstance(x, (list, tuple)):
        return ' '.join(stringify(xi) for xi in x)
    if isinstance(x, (bytes, bytearray)):
        return x.hex()
    return str(x)


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', action='store_true')
    parser.add_argument('--timeout', type=int, default=10)
    parser.add_argument('--server', default='/tmp/serial_server')
    parser.add_argument('command', choices=commands.keys())
    parser.add_argument('args', nargs='*')
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)

    reader, writer = await asyncio.open_unix_connection(args.server)
    read_queue = create_read_queue(reader)
    write_queue = create_write_queue(writer)

    command = commands[args.command]

    try:
        results = await asyncio.wait_for(command(read_queue, write_queue, *args.args), timeout=args.timeout)
        print(stringify(results))
    except asyncio.TimeoutError:
        print('command timed out')
        sys.exit(1)
    except AssertionError:
        print('command error')
        sys.exit(1)

    writer.close()

asyncio.run(main())
