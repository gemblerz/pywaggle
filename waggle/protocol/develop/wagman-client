#!/usr/bin/env python3
import argparse
import asyncio
import sys
import binascii
from protocol import pack_sensorgram, unpack_sensorgram, unpack_sensorgrams


async def read_queue_task(reader, queue):
    while True:
        data = await reader.readline()

        try:
            messages = unpack_sensorgrams(binascii.a2b_base64(data))
        except (binascii.Error, IndexError):
            continue

        for message in messages:
            await queue.put(message)


def create_read_queue(reader):
    queue = asyncio.Queue()
    asyncio.create_task(read_queue_task(reader, queue))
    return queue


async def write_queue_task(writer, queue):
    while True:
        message = await queue.get()
        writer.write(binascii.b2a_base64(pack_sensorgram(message)))
        await writer.drain()


def create_write_queue(writer):
    queue = asyncio.Queue()
    asyncio.create_task(write_queue_task(writer, queue))
    return queue


def match_message(fields, msg):
    for k in fields.keys():
        if k not in msg or msg[k] != fields[k]:
            return False
    return True


async def get_message(reader, fields):
    while True:
        message = await reader.get()
        if match_message(fields, message):
            return message


async def simple_rpc(reader, writer, id, sub_id=None, value=None):
    await writer.put({'id': id, 'sub_id': sub_id or 0, 'value': value or 0})

    match = {'id': id}

    if sub_id is not None:
        match['sub_id'] = sub_id

    r = await get_message(reader, match)
    return r['value']


async def wait_for_messages(reader, matches):
    results = {}

    while len(results) < len(matches):
        message = await reader.get()

        for i, match in enumerate(matches):
            if match_message(match, message):
                results[i] = message['value']

    return tuple(results[i] for i in range(len(results)))


async def command_id(reader, writer, *args):
    return await simple_rpc(reader, writer, id=1)


async def command_cu(reader, writer, *args):
    return await simple_rpc(reader, writer, id=2)


async def command_hb(reader, writer, *args):
    return await simple_rpc(reader, writer, id=3)


async def command_boots(reader, writer, *args):
    return await simple_rpc(reader, writer, id=4)


async def command_uptime(reader, writer, *args):
    return await simple_rpc(reader, writer, id=7)


async def command_fc(reader, writer, *args):
    await asyncio.gather(
        writer.put({'id': 0xff05, 'sub_id': 1, 'value': 0}),
        writer.put({'id': 0xff05, 'sub_id': 2, 'value': 0}),
        writer.put({'id': 0xff05, 'sub_id': 3, 'value': 0}),
        writer.put({'id': 0xff05, 'sub_id': 4, 'value': 0}),
        writer.put({'id': 0xff05, 'sub_id': 5, 'value': 0}),
    )

    return await wait_for_messages(reader, [
        {'id': 0xff05, 'sub_id': 1},
        {'id': 0xff05, 'sub_id': 2},
        {'id': 0xff05, 'sub_id': 3},
        {'id': 0xff05, 'sub_id': 4},
        {'id': 0xff05, 'sub_id': 5},
    ])


async def command_th(reader, writer, *args):
    return await simple_rpc(reader, writer, id=34)


async def command_start(reader, writer, *args):
    port = int(args[0])
    assert await simple_rpc(reader, writer, id=5, value=(port,)) == 0


async def command_stop(reader, writer, *args):
    port = int(args[0])
    dur = int(args[1])
    assert await simple_rpc(reader, writer, id=6, value=(port, dur)) == 0


async def command_eereset(reader, writer, *args):
    return await simple_rpc(reader, writer, id=30)


async def command_reset(reader, writer, *args):
    return await simple_rpc(reader, writer, id=31)


commands = {
    'id': command_id,
    'cu': command_cu,
    'hb': command_hb,
    'fc': command_fc,
    'up': command_uptime,
    'th': command_th,
    'uptime': command_uptime,
    'boots': command_boots,
    'start': command_start,
    'stop': command_stop,
    'eereset': command_eereset,
    'reset': command_reset,
}


def stringify(x):
    if isinstance(x, (list, tuple)):
        return ' '.join(stringify(xi) for xi in x)
    if isinstance(x, (bytes, bytearray)):
        return x.hex()
    return str(x)


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--server', default='/tmp/serial_server')
    parser.add_argument('command', choices=commands.keys())
    parser.add_argument('args', nargs='*')
    args = parser.parse_args()

    reader, writer = await asyncio.open_unix_connection(args.server)
    read_queue = create_read_queue(reader)
    write_queue = create_write_queue(writer)

    command = commands[args.command]

    try:
        results = await asyncio.wait_for(command(read_queue, write_queue, *args.args), timeout=10)
        print(stringify(results))
    except asyncio.TimeoutError:
        print('command timed out')
        sys.exit(1)
    except AssertionError:
        print('command error')
        sys.exit(1)

    writer.close()

asyncio.run(main())
