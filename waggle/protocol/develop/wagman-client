#!/usr/bin/env python3
import argparse
import asyncio
import sys
import binascii
from protocol import pack_sensorgram, unpack_sensorgram, unpack_sensorgrams


async def read_queue_task(reader, queue):
    while True:
        data = await reader.readline()

        try:
            messages = unpack_sensorgrams(binascii.a2b_base64(data))
        except (binascii.Error, IndexError):
            continue

        for message in messages:
            await queue.put(message)


def create_read_queue(reader):
    queue = asyncio.Queue()
    asyncio.create_task(read_queue_task(reader, queue))
    return queue


async def write_queue_task(writer, queue):
    while True:
        message = await queue.get()
        writer.write(binascii.b2a_base64(pack_sensorgram(message)))
        await writer.drain()


def create_write_queue(writer):
    queue = asyncio.Queue()
    asyncio.create_task(write_queue_task(writer, queue))
    return queue


async def get_responses(reader, id, sub_ids):
    results = {}
    matches = [{'id': id, 'sub_id': sub_id} for sub_id in sub_ids]

    while len(results) < len(matches):
        message = await reader.get()

        for i, match in enumerate(matches):
            if match_message(match, message):
                results[i] = message['value']

    return tuple(results[i] for i in range(len(results)))


def match_message(fields, msg):
    for k in fields.keys():
        if k not in msg or msg[k] != fields[k]:
            return False
    return True


REQ_WAGMAN_ID = 0xc000
REQ_WAGMAN_CU = 0xc001
REQ_WAGMAN_HB = 0xc002
REQ_WAGMAN_TH = 0xc003
REQ_WAGMAN_UPTIME = 0xc004
REQ_WAGMAN_BOOTS = 0xc005
REQ_WAGMAN_FC = 0xc006
REQ_WAGMAN_START = 0xc007
REQ_WAGMAN_STOP = 0xc008
REQ_WAGMAN_RESET = 0xc009
REQ_WAGMAN_EERESET = 0xc00a
REQ_WAGMAN_DEVICE_STATE = 0xc00b

PUB_WAGMAN_ID = 0xff1a
PUB_WAGMAN_CU = 0xff06
PUB_WAGMAN_HB = 0xff09
PUB_WAGMAN_BOOTS = 0xff1a
PUB_WAGMAN_UPTIME = 0xff14
PUB_WAGMAN_FC = 0xff05
PUB_WAGMAN_START = 0xff0b
PUB_WAGMAN_STOP = 0xff0a
PUB_WAGMAN_ENABLE = 40
PUB_WAGMAN_EERESET = 0xc00a
PUB_WAGMAN_RESET = 0xc009
PUB_WAGMAN_PING = 0xff1e
PUB_WAGMAN_VOLTAGE = 0xff08
PUB_WAGMAN_TH = 0xff10
PUB_WAGMAN_DEVICE_STATE = 0xff1f
PUB_WAGMAN_DEVICE_ENABLE = 0xff20


def ints(args):
    return [int(x) for x in args]


async def put_request(writer, id, sub_ids):
    return await asyncio.gather(*[writer.put({'id': id, 'sub_id': sub_id, 'value': 0})
                                  for sub_id in sub_ids])


async def command_id(reader, writer, *args):
    await put_request(writer, REQ_WAGMAN_ID, [1])
    return await get_responses(reader, PUB_WAGMAN_ID, [1])


async def command_cu(reader, writer, *args):
    ports = ints(args) or [1, 2, 3, 4, 5, 6]
    await put_request(writer, REQ_WAGMAN_CU, ports)
    return await get_responses(reader, PUB_WAGMAN_CU, ports)


async def command_hb(reader, writer, *args):
    ports = ints(args) or [1, 2, 3, 4, 5]
    await put_request(writer, REQ_WAGMAN_HB, ports)
    return await get_responses(reader, PUB_WAGMAN_HB, ports)


async def command_boots(reader, writer, *args):
    await put_request(writer, REQ_WAGMAN_BOOTS, [1])
    return await get_responses(reader, PUB_WAGMAN_BOOTS, [1])


async def command_uptime(reader, writer, *args):
    await put_request(writer, REQ_WAGMAN_BOOTS, [1])
    return await get_responses(reader, PUB_WAGMAN_BOOTS, [1])


async def command_fc(reader, writer, *args):
    ports = ints(args) or [1, 2, 3, 4, 5]
    await put_request(writer, REQ_WAGMAN_FC, ports)
    return await get_responses(reader, PUB_WAGMAN_FC, ports)


async def command_th(reader, writer, *args):
    ports = ints(args) or [1, 2, 3, 4, 5]
    await put_request(writer, REQ_WAGMAN_TH, ports)
    return await get_responses(reader, PUB_WAGMAN_TH, ports)


async def command_start(reader, writer, *args):
    port = int(args[0])
    await writer.put({'id': REQ_WAGMAN_START, 'sub_id': port, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_START, [port])


async def command_stop(reader, writer, *args):
    port = int(args[0])
    after = int(args[1])
    await writer.put({'id': REQ_WAGMAN_STOP, 'sub_id': port, 'value': after})
    return await get_responses(reader, PUB_WAGMAN_STOP, [port])


async def command_eereset(reader, writer, *args):
    await writer.put({'id': REQ_WAGMAN_EERESET, 'sub_id': 1, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_EERESET, [1])


async def command_reset(reader, writer, *args):
    await writer.put({'id': REQ_WAGMAN_RESET, 'sub_id': 1, 'value': 0})
    return await get_responses(reader, PUB_WAGMAN_RESET, [1])


commands = {
    'id': command_id,
    'cu': command_cu,
    'hb': command_hb,
    'fc': command_fc,
    'up': command_uptime,
    'th': command_th,
    'uptime': command_uptime,
    'boots': command_boots,
    'start': command_start,
    'stop': command_stop,
    'eereset': command_eereset,
    'reset': command_reset,
}


def stringify(x):
    if isinstance(x, (list, tuple)):
        return ' '.join(stringify(xi) for xi in x)
    if isinstance(x, (bytes, bytearray)):
        return x.hex()
    return str(x)


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--server', default='/tmp/serial_server')
    parser.add_argument('command', choices=commands.keys())
    parser.add_argument('args', nargs='*')
    args = parser.parse_args()

    reader, writer = await asyncio.open_unix_connection(args.server)
    read_queue = create_read_queue(reader)
    write_queue = create_write_queue(writer)

    command = commands[args.command]

    try:
        results = await asyncio.wait_for(command(read_queue, write_queue, *args.args), timeout=10)
        print(stringify(results))
    except asyncio.TimeoutError:
        print('command timed out')
        sys.exit(1)
    except AssertionError:
        print('command error')
        sys.exit(1)

    writer.close()

asyncio.run(main())
